\documentclass{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}

\title{CS440 Assignment 1}
\author{Shruti Shukla, Yakelin Melendez-Gonzalez, Maruah Abedin}

\begin{document}

\maketitle

\section{Part 0: Gridworld Generation}

We generated 50 independent $101 \times 101$ gridworlds using a depth-first search (DFS) based exploration process. Initially, all cells were marked as unvisited. The algorithm begins from a randomly selected cell, marks it as visited, and assigns it as unblocked. From there, a random unvisited neighbor is selected.

When a cell is first visited, it is marked as blocked with probability $0.3$ and unblocked with probability $0.7$. Unblocked cells are added to the DFS stack to continue exploration. Whenever a cell has no unvisited neighbors, the algorithm backtracks until it finds a cell with remaining unvisited neighbors. This process continues until all cells in the grid have been visited.

This procedure naturally produces maze- or corridor-like environments. DFS tends to create long, structured passages, while the probabilistic blocking introduces stochastic obstacle placement. Each gridworld is generated using a fixed random seed to ensure full reproducibility across runs.

The generated gridworlds are saved to disk and can be reloaded for visualization and experimentation.

\section{Part 1: Conceptual Questions}

\subsection{(a) Why is the first move east instead of north in Figure 8?}

In Figure 8, the agent initially doesn't know which cells are blocked. Under the freespace assumption, all unobserved cells are treated as unblocked. The agent therefore runs A* search using the Manhattan distance heuristic to compute a shortest presumed-unblocked path to the target.

From the start cell, moving east and moving north both incur the same step cost, giving identical $g$-values. Since the Manhattan heuristic depends only on grid distance to the target, both successors also have identical $h$-values. Consequently, their $f = g + h$ values are equal.

When multiple states share the same smallest $f$-value, A* relies on its tie-breaking rule. In the assignment examples, ties are broken in favor of states with larger $g$-values, with any remaining ties resolved consistently. Under this deterministic ordering, the east successor is selected before the north successor.

Thus, the initial move east is not inherently better than moving north. It is simply a consequence of tie-breaking among equally optimal successors under the freespace assumption.

\subsection{(b) Proof that Repeated A* terminates in finite time and makes at most $U^2$ moves}

Let $U$ denote the number of unblocked cells in the true gridworld.

Repeated A* alternates between planning and execution. At each planning phase, A* computes a shortest presumed-unblocked path based on the agentâ€™s current knowledge. The agent then follows this path until either the target is reached or a previously unknown blocked cell invalidates the path.

Termination follows from the finiteness of the gridworld. Each time a planned path fails, the agent observes at least one previously unknown blocked cell. Since the number of cells is finite, only finitely many such discoveries can occur. Therefore, only finitely many replanning events are possible, and the algorithm must terminate in finite time.

To bound the number of moves, observe that within any single planning episode, the agent follows a shortest path. Shortest paths are simple, meaning no cell is visited more than once. Since there are at most $U$ unblocked cells, the number of moves in one episode is at most $U$.

A new planning episode occurs only when new information invalidates the current path. Because the gridworld is finite, the number of such episodes is bounded. In the worst case, there can be at most $U$ planning episodes that result in movement.

Hence,

\[
\text{total moves} \le U \times U = U^2.
\]

Therefore, the number of moves made by Repeated A* is bounded from above by $U^2$.

\section{Part 2: Effects of Tie-Breaking}

Repeated Forward A* requires a tie-breaking strategy when multiple frontier states share the same minimum $f = g + h$ value. We implemented two variants that differ only in how ties are resolved:

\begin{itemize}
    \item Favor smaller $g$-values (shallower nodes)
    \item Favor larger $g$-values (deeper nodes)
\end{itemize}

Both variants were evaluated on the same set of 50 deterministic $101 \times 101$ gridworlds generated in Part 0. To avoid runtime variability, performance was measured using the total number of expanded cells, summed across all A* searches performed during execution.

\subsection{Results}

Across the 50 gridworlds, the variant favoring larger $g$-values consistently expanded fewer cells. The mean number of expanded cells was substantially lower when ties were broken in favor of larger $g$-values compared to smaller $g$-values. The mean number of expanded cells was 66295.46 for the smaller-$g$ variant and 48419.82 for the larger-$g$ variant.

\subsection{Explanation}

The observed difference is a direct consequence of how A* behaves when many states share identical $f$-values. Favoring smaller $g$-values biases the search toward states closer to the start, which produces a broader, wavefront-like expansion pattern. This behavior resembles breadth-first exploration within an equal-$f$ contour and often leads to expanding many laterally equivalent states.

In contrast, favoring larger $g$-values prioritizes deeper nodes along candidate paths. This biases the search toward continuing progress toward the goal rather than expanding outward near the start. In grid environments using the Manhattan distance heuristic, large regions of equal $f$-values frequently arise, making the tie-breaking rule a dominant factor in determining the search footprint.

Favoring larger $g$-values therefore reduces unnecessary lateral exploration and typically results in fewer expanded cells overall, which aligns with the empirical results.


\section{Part 3: Forward vs. Backward}

We compared Repeated Forward A* and Repeated Backward A* in the standard unknown gridworld setting. The agent initially assumes all cells are unblocked, senses the blockage status of its 4 neighboring cells at each step, updates its internal map, and replans whenever the current path becomes invalid. In both variants, ties were broken in favor of larger g-values, as specified in the assignment.

Performance was measured by the total number of expanded cells over the entire execution.

Both algorithm were evaluated on the same set of 50 deterministic 101 * 101 gridworlds generated in Part 0. Repeated Forward A* expanded an average of 25,536.06 cells, while Repeated Backward A* expanded an average of 164,962.08 cells.

These results show that Repeated Backward A* is significantly less efficient than Repeated Forward A* in this setting.The key reason for this difference lies in the direction of search relative to the agent's knowledge. Repeated Forward A* plans from the agent's current position toward the goal, which focuses the search on regions that are gradually being revealed through sensing.

In contrast, Repeated Backward A* plans from the goal toward the agent's current position, causing it to explore large regions near the goal that the agent has not yet discovered and may not be able to reach. As a result, Backward A* performs substantially more unnecessary search, leading to a much higher number of expanded cells.

\section{Part 4: Heuristics in Adaptive A*}

\subsection{Consistency of Manhattan Distance}

In this project, A* uses the Manhattan distance as its heuristic, which is the sum of the horizontal and vertical distances from a cell to the goal. The agent can only move in the four main directions, and each move has a cost of 1.

A heuristic is called \emph{consistent} if, when moving from a cell to one of its neighbors, the heuristic value does not decrease by more than the cost of that move. In other words, the estimated distance to the goal should change smoothly between neighboring cells.

When the agent moves to a neighboring cell, either the $x$ or $y$ coordinate changes by exactly 1. This means the Manhattan distance to the goal can only change by at most 1 in a single move. Since each move also costs 1, the Manhattan distance heuristic satisfies the consistency condition.

Therefore, the Manhattan distance is a consistent heuristic in gridworlds where movement is limited to the four main directions. Because consistent heuristics are also admissible, the Manhattan distance also never overestimates the true shortest path to the goal.

\subsection{Consistency of the Adaptive A* Heuristic}

Adaptive A* updates the heuristic values after each A* search. For each expanded state $s$, the new heuristic is computed as:
\[
h_{\text{new}}(s) = g(\text{goal}) - g(s),
\]
where $g(s)$ is the cost to reach $s$ and $g(\text{goal})$ is the cost of the path found to the goal.

We start with a consistent heuristic (the Manhattan distance). The updated heuristic is based on these same path costs, so the difference between the heuristic values of two neighboring cells cannot be larger than the cost of moving between them. This means the updated heuristic also satisfies the consistency condition.

Therefore, Adaptive A* keeps the heuristic consistent even after updating it. Since the heuristic remains consistent, it also remains admissible. This ensures that each A* search still finds an optimal path for the currently known grid, while usually expanding fewer states as the heuristic becomes more accurate over time.

\section{Part 5: Heuristics in the Adaptive A*}
In part 5, we implemented and compared Repeated Forward A* and Adaptive A* in the unknown grid world setting. The agent assumes all cells are unblocked to begin with in both algorithms. Sensing neighboring cells, the agent updates it's knowledge of the grid, and replans it's path when the current path it is on becomes invalid.

Both algorithms break ties among cells with the same $f$-values in favor of cells with larger $g$-values and remaining ties in an identical way. 

The Adaptive A* algorithm differs from Repeated Forward A* by updating heuristic values after each A* search. For each expanded state $s$, the heuristic is computed as:
\[
h(s) = g(\text{goal}) - g(s),
\]
where $g(s)$ is the cost to reach $s$ during the most recent search. The updated heuristic valuees are reused when replanning paths.

\subsection{Results}
Both algorithms were evaluated on the same 50 $101 \times 101$ gridworlds generated in part 0. We measured the performance of the algorithms by using the total number of cells expanded across the execution.

Repeated Forward A* yielded an average of 25,536.06 cells expanded, whereas Adaptive A* averaged 24,664.80 cells expanded. From this we observed that Adaptive A* produced roughly 871 fewer cells than Repeated Forward A*.

Thus, Adaptive A* resulted in a 3.4\% reduction of number of expanded cells.

Adaptive A* yielded these results because it reuses information stored from previous searches. After each step during replanning, the heuristic values of expanded states are updated to accurately reflect the cost of the discovered path. Therefore, Adaptive A* is better informed and can accurately determine the true shortest paths.

These results are better reflected on more difficult grid worlds that may require frequent replanning as Adaptive A* reduces redundancy, expanding fewer states. On easier grid worlds, Adaptive A* and Repeated Forward A* behave similarly as the agent reaches the goal state with minimal or no replanning.

\section{Part 6: Statistical Significance}

To determine whether the performance difference between two algorithms is systematic or due to sampling noise, statistical hypothesis tests can be applied. 

Being that both algorithms are evaluated and compared using the same 50 grid worlds, the measurements are naturally paired. Thus, in such a case a paired $t$-test could be applied. A paired $t$-test is a statistical method used to determine whether the mean difference between pairs of measurements is zero or not. 

A mean difference of zero would imply that both algorithms perform equally.

If performing such a test, for each gridworld $i$, we let $X_i$ denote the number of expanded cells for Repeated Forward A* and $Y_i$ for Adaptive A*.

We begin by defining the paired differences: 
\[
D_i = X_i - Y_i.
\]

The null hypothesis is:
\[
H_0: \mu_D = 0,
\]
this states there is no systematic difference in performance.

The alternate hypothesis is:
\[
H_1: \mu_D > 0,
\]
this states that Adaptive A* expands fewer cells on average.

A paired $t$-test would then be performed on the differences.

Computing the test statistic:
The sample mean of the differences would be
  \[
  \bar{D} = \frac{1}{n} \sum_{i=1}^{n} D_i
  \]

which would tell us how much better Adaptive A* is on average. 

The sample standard deviation of the differences would be $s_D$, letting us know how consistent the differences are.

The test statistic is then:
\[
t = \frac{\bar{D}}{s_D / \sqrt{n}},
\]
where $n = 50$

Under the null hypothesis, the test statistic follows a $t$-distribution with $n-1$ degrees of freedom. This is used to compute a $p$-value, which measures how likely it is to observe our results if there were no true difference between the algorithms. 

If the $p$-value is less than a chosen significance level (e.g., $\alpha = 0.05$), the null hypothesis is rejected and can conclude that the difference is statistically significant.

Ultimately, such a test would allow us to determine whether the reduced number of cells expanded by Adaptive A* is statistically significant or simply due to random variation in the sampled gridworlds.

\end{document}
